# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["ElasticMultipleTypeQuestion","ElasticMultipleTypeQuestionSet","ElasticMultipleTypeQuestionValidation","ElasticQuestion","ElasticSet",]
        ), enums=set(
          ["Category",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 1
    # #########################################################################

    @property
    def Category(self) -> "CategoryViewer":
        return CategoryViewer(self)


    # #########################################################################
    # Generated classes 5
    # #########################################################################

    @property
    def ElasticMultipleTypeQuestion(self) -> "ElasticMultipleTypeQuestionViewer":
        return ElasticMultipleTypeQuestionViewer(self)

    @property
    def ElasticMultipleTypeQuestionSet(self) -> "ElasticMultipleTypeQuestionSetViewer":
        return ElasticMultipleTypeQuestionSetViewer(self)

    @property
    def ElasticMultipleTypeQuestionValidation(self) -> "ElasticMultipleTypeQuestionValidationViewer":
        return ElasticMultipleTypeQuestionValidationViewer(self)

    @property
    def ElasticQuestion(self) -> "ElasticQuestionViewer":
        return ElasticQuestionViewer(self)

    @property
    def ElasticSet(self) -> "ElasticSetViewer":
        return ElasticSetViewer(self)



# #########################################################################
# Generated enums 1
# #########################################################################

class CategoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Category")
        self._values: typing.Set[str] = set([  "QUERY_DSL",  "AGGREGATIONS",  "SCRIPTING",  ])
        self._vals = CategoryValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CategoryValues":
        return self._vals


class CategoryViewer(CategoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CategoryValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def QUERY_DSL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("QUERY_DSL"))
    
    @property
    def AGGREGATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AGGREGATIONS"))
    
    @property
    def SCRIPTING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCRIPTING"))
    
    



# #########################################################################
# Generated classes 5
# #########################################################################

class ElasticMultipleTypeQuestionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ElasticMultipleTypeQuestion")
        self._properties: typing.Set[str] = set([  "question",  "answer",  "questionType",  ])
        self._props = ElasticMultipleTypeQuestionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ElasticMultipleTypeQuestionProperties":
        return self._props


class ElasticMultipleTypeQuestionViewer(ElasticMultipleTypeQuestionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ElasticMultipleTypeQuestionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def answer(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("answer"))
    
    @property
    def questionType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("questionType"))
    
    


class ElasticMultipleTypeQuestionSetAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ElasticMultipleTypeQuestionSet")
        self._properties: typing.Set[str] = set([  "questionClass",  "validationClass",  ])
        self._props = ElasticMultipleTypeQuestionSetProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ElasticMultipleTypeQuestionSetProperties":
        return self._props


class ElasticMultipleTypeQuestionSetViewer(ElasticMultipleTypeQuestionSetAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ElasticMultipleTypeQuestionSetProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def questionClass(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("questionClass"))
    
    @property
    def validationClass(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("validationClass"))
    
    


class ElasticMultipleTypeQuestionValidationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ElasticMultipleTypeQuestionValidation")
        self._properties: typing.Set[str] = set([  "isValid",  "reason",  "location",  ])
        self._props = ElasticMultipleTypeQuestionValidationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ElasticMultipleTypeQuestionValidationProperties":
        return self._props


class ElasticMultipleTypeQuestionValidationViewer(ElasticMultipleTypeQuestionValidationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ElasticMultipleTypeQuestionValidationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def isValid(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("isValid"))
    
    @property
    def reason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reason"))
    
    @property
    def location(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("location"))
    
    


class ElasticQuestionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ElasticQuestion")
        self._properties: typing.Set[str] = set([  "category",  "question",  "endpoint",  "method",  "answer",  ])
        self._props = ElasticQuestionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ElasticQuestionProperties":
        return self._props


class ElasticQuestionViewer(ElasticQuestionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ElasticQuestionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def endpoint(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("endpoint"))
    
    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))
    
    @property
    def answer(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("answer"))
    
    


class ElasticSetAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ElasticSet")
        self._properties: typing.Set[str] = set([  "corpus",  "rating",  ])
        self._props = ElasticSetProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ElasticSetProperties":
        return self._props


class ElasticSetViewer(ElasticSetAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ElasticSetProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def corpus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("corpus"))
    
    @property
    def rating(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rating"))
    
    

